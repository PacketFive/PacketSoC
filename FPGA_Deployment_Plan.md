# FPGA Synthesis and Deployment Plan: Keystone SoC on Microchip PolarFire

## 0. Document Purpose

This document outlines the plan for synthesizing the Keystone SoC design, targeting a Microchip PolarFire SoC FPGA, and the subsequent board bring-up and testing strategy.

## 1. FPGA Design Flow Setup

### 1.1. Required Tools
*   **Libero SoC Design Suite:** Microchip's primary FPGA design software. The specific version will be chosen based on PolarFire SoC device support and stability (e.g., Libero SoC v2023.x or newer).
*   **Synthesis Tool:** Synopsys Synplify Pro, which is integrated within Libero SoC.
*   **Place & Route Tool:** Libero SoC's integrated P&R engine.
*   **Simulation Tool:** Mentor QuestaSim or ModelSim (often bundled or compatible with Libero) for post-synthesis and post-P&R simulations if needed, though primary verification happens pre-synthesis.
*   **Programming and Debug Tools:** FlashPro programmer and associated software for bitstream loading and JTAG debugging.

### 1.2. PolarFire-Specific IP Cores
The generic RTL stubs used for simulation will need to be replaced or configured with PolarFire SoC specific IP cores for key functionalities:
*   **DDR Controller (PF_DDR_PHY, CoreDDR):**
    *   The `Main_Memory_Ctrl_Stub.v` will be replaced by Microchip's CoreDDR IP, configured for the specific DDR type (e.g., DDR4) and parameters of the target PolarFire SoC evaluation board.
    *   This includes configuring the PF_DDR_PHY.
    *   The AXI interface of CoreDDR will connect to the AXI Interconnect (Slave Port S0).
*   **Clocking Resources (PF_CCC - CoreClockControl):**
    *   A PF_CCC IP core will be used to generate and distribute various clocks required by the SoC (e.g., CPU clock, AXI interconnect clock, DDR clock, peripheral clocks) from the on-board oscillator(s).
    *   Careful planning of clock domains and synchronization paths will be necessary.
*   **Reset System (CoreReset):**
    *   The `CoreReset` IP can be used to manage the reset distribution and synchronization across different clock domains.
*   **MSS (Microprocessor SubSystem) Configuration:**
    *   The PolarFire SoC includes a hardened MSS with its own RISC-V CPU complex, peripherals (like UART, SPI, Ethernet), and memory controllers.
    *   For this project, we are implementing a custom SoC in the FPGA fabric, including the CVA6 CPU. However, we might leverage some MSS peripherals if desired or use the MSS for debugging/bootstrapping.
    *   If the CVA6 is to be the primary application processor, the MSS might be configured in a minimal mode or used as a co-processor/service provider. For this plan, we assume CVA6 is the primary and we'll implement fabric-based peripherals.
*   **PHYs for External Interfaces (if any beyond basic UART):**
    *   If the SoC needs Ethernet, PCIe, etc., corresponding PolarFire Transceiver (PF_XCVR) blocks and protocol IP cores would be required. (Currently not in scope based on existing stubs).
*   **Boot Medium:**
    *   The method for loading the initial CVA6 boot code (and potentially the nano-controller firmware) needs to be determined (e.g., from external SPI flash connected to FPGA fabric, or loaded via JTAG/debugger into BRAMs initially). The `Boot_ROM_Stub.v` will be implemented as a BRAM initialized at synthesis/programming time.

### 1.3. Constraint File Development
*   **Timing Constraints (`.sdc` - Synopsys Design Constraints):**
    *   **Clock Definitions:** `create_clock` for all input clocks (from oscillators). `create_generated_clock` for clocks generated by PF_CCC.
    *   **Clock Uncertainty and Latency:** Define jitter and latency for primary clocks.
    *   **Input/Output Delays:** `set_input_delay` and `set_output_delay` for all I/O pins relative to their respective clocks (e.g., UART_TX, UART_RX, AXI interface pins if any are external). This requires board-level timing information.
    *   **False Paths:** `set_false_path` for asynchronous reset signals, paths between unrelated clock domains (if not properly synchronized), and test logic.
    *   **Multicycle Paths:** `set_multicycle_path` if any paths are known to take multiple clock cycles and this is acceptable by design (e.g., some control signals to slow peripherals).
    *   **Max/Min Delay Constraints:** If specific path delays are critical.
*   **Pin Constraints (`.pdc` - Physical Design Constraints):**
    *   Assign SoC top-level I/O signals (clk, resetn, UART_TX, UART_RX, JTAG, etc.) to specific FPGA package pins based on the target PolarFire SoC evaluation board's schematic and user guide.
    *   Define I/O standards (e.g., LVCMOS33, LVDS) and other I/O attributes (pull-ups, drive strength) for each pin.
*   **Floorplanning Constraints (Optional):**
    *   If needed for timing closure or to manage critical paths, regions can be defined on the FPGA for specific modules.

## 2. RTL Preparation for Synthesis

### 2.1. Memory Mapping (RAMs/ROMs to BRAMs/LSRAMs)
*   **Libero SoC Memory Inference:**
    *   The Verilog `reg [DATA_WIDTH-1:0] memory_array [0:DEPTH-1];` style used in stubs is generally synthesizable and will be inferred by Synplify Pro as block RAM (BRAM/LSRAM).
    *   **Boot ROM (`Boot_ROM_Stub.v`):** Will be mapped to BRAM.
    *   **Keystone CCU Internal Registers:** These are flip-flop based, not block RAMs.
    *   **eBPF VM Slot Memories:**
        *   `prog_mem`: Mapped to BRAM.
        *   `stack_mem`: Mapped to BRAM.
        *   `nano_ctrl_instr_rom`: Mapped to BRAM.
        *   `nano_ctrl_data_ram`: Mapped to BRAM.
*   **Initialization File Formats:**
    *   **ROMs (`Boot_ROM_Stub.v`, `nano_ctrl_instr_rom`):**
        *   Use `$readmemh` in the Verilog code to initialize ROMs.
        *   The hex files (e.g., `boot_content.hex`, `nano_firmware.hex`) will be provided to Libero SoC as part of the design source files. Libero will ensure these are used to initialize the BRAMs during bitstream generation.
        *   The format is typically plain ASCII hex, one word per line.
*   **Memory Types:** PolarFire SoCs have LSRAM (Large SRAM, ~2Kbit blocks) and BRAM (uRAM, ~20Kbit blocks). The synthesis tool will choose the appropriate type based on size and configuration. Attributes might be used in RTL to guide this if specific packing is needed (e.g., `(* ramstyle = "block" *)`).

### 2.2. Synthesizable AXI Interconnect
*   The current `AXI_Interconnect.v` is a stub with only port definitions and comments.
*   **Requirement:** This needs to be replaced with a fully functional, synthesizable AXI interconnect module.
*   **Options:**
    *   **Develop Custom Interconnect:** Implement address decoders, arbiters (round-robin or fixed priority), and multiplexers in Verilog. This provides full control but is a significant effort.
    *   **Use IP Core:** Microchip Libero SoC provides an AXI Bus Fabric IP (`CoreAXIInterconnect`) or similar system builder tools (SmartDesign) that can generate an interconnect based on configuration. This is the recommended approach for complexity management and reliability.
    *   **Third-Party IP:** Commercial AXI interconnect IP could also be considered.
*   **Configuration:** The interconnect will be configured with:
    *   Number of AXI master and slave ports.
    *   AXI data width (32-bit).
    *   Address width (32-bit).
    *   Address map based on `SoC_Memory_Map.txt`.
    *   Arbitration scheme.
    *   AXI Full to AXI-Lite conversion capabilities where needed (M0 to S1/S2).

### 2.3. Clocking and Reset Strategy
*   **Clocking:**
    *   One or more primary clock inputs from the FPGA board (e.g., 50MHz or 100MHz oscillator).
    *   Use the `PF_CCC` IP to generate:
        *   CPU clock (e.g., 100-250MHz, depending on timing closure).
        *   AXI interconnect clock (often synchronous with CPU clock, or a divided version).
        *   Keystone Coprocessor clock (can be same as interconnect or different).
        *   DDR memory controller clock (requires specific frequencies from DDR PHY).
        *   Peripheral clock (can be slower, e.g., 50MHz).
    *   Clock domain crossings (CDCs) must be handled carefully with proper synchronizers (e.g., 2-flop synchronizers for single-bit signals, asynchronous FIFOs for data paths if clocks are asynchronous).
*   **Reset:**
    *   A single active-low global reset input (`resetn`) to the SoC.
    *   Use the `CoreReset` IP or custom logic to:
        *   Synchronize the external asynchronous reset to the main clock domain.
        *   Generate synchronized reset signals for different clock domains.
        *   Ensure proper reset sequencing if required by different IP blocks (e.g., DDR controller).

## 3. Synthesis, Place & Route (P&R) Process

### 3.1. General Steps in Libero SoC
1.  **Project Creation:** Create a new Libero project, selecting the target PolarFire SoC device and package.
2.  **Design Entry:**
    *   Import all Verilog RTL files (`SoC_Top.v`, CPU, Keystone modules, peripherals, new AXI interconnect, etc.).
    *   Import memory initialization files (`.hex`).
    *   Instantiate and configure PolarFire-specific IP cores (DDR controller, CCC, CoreReset) using the Libero IP Catalog and SmartDesign system builder tool.
3.  **Constraint Management:**
    *   Add SDC and PDC files to the project.
4.  **Synthesis:**
    *   Run Synplify Pro synthesis.
    *   Specify `SoC_Top` as the top-level module.
    *   Review synthesis reports for warnings, errors, and initial resource estimates.
5.  **Place and Route:**
    *   Import synthesis results into Libero's P&R flow.
    *   Run Place and Route.
    *   Libero will attempt to meet timing constraints.
6.  **Timing Analysis (Static Timing Analysis - STA):**
    *   Analyze post-P&R timing reports (e.g., from SmartTime in Libero).
    *   Identify critical paths and timing violations (setup and hold).
7.  **Power Analysis (Optional but Recommended):**
    *   Use Libero's power analysis tools to estimate power consumption.

### 3.2. Key Reports to Analyze
*   **Synthesis Report:**
    *   Inferred logic, register counts, FSM encodings.
    *   Initial clock frequency estimates.
    *   Warnings about unoptimized logic or potential issues (e.g., latches inferred, undriven signals).
    *   Resource utilization estimates (LUTs, FFs, RAM blocks).
*   **Place & Route Report:**
    *   Final resource utilization (LUTs, FFs, DSPs, RAMs).
    *   Routing congestion details.
*   **Timing Report (SmartTime):**
    *   Worst Negative Slack (WNS) and Total Negative Slack (TNS) for all clock domains.
    *   Critical path details (start point, end point, logic levels, net delays).
    *   Hold time violations.
    *   Unconstrained paths.
*   **Power Report:** Estimated static and dynamic power consumption.

### 3.3. Iteration Strategies for Timing Closure
*   **Review Constraints:** Ensure SDC constraints are correct and realistic. Check for missing constraints or overly restrictive ones.
*   **RTL Modifications:**
    *   Pipeline long combinatorial paths by adding registers.
    *   Optimize FSM encodings.
    *   Reduce fanout on critical nets.
    *   Re-structure logic if it's causing routing congestion.
*   **Synthesis Options:** Experiment with different Synplify Pro effort levels, FSM compiler options, retiming, etc.
*   **Place & Route Options (Libero):**
    *   Different effort levels.
    *   Physical optimization strategies (e.g., register duplication, path optimization).
    *   Floorplanning critical modules if necessary.
*   **Clock Speed Adjustment:** If timing closure is very difficult, consider reducing the target clock frequencies for problematic domains.

## 4. Bitstream Generation
*   Once P&R completes successfully and timing constraints are met (or acceptable waivers are in place), generate the FPGA programming bitstream file using Libero.
*   This file will be used to program the PolarFire SoC FPGA.

## 5. Board Bring-up and Testing Strategy

### 5.1. Initial Hardware Setup
*   Target PolarFire SoC evaluation board (e.g., Icicle Kit).
*   Connect power supply.
*   Connect JTAG programmer (FlashPro) to the PC and the board.
*   Connect UART interface (from the relevant FPGA pins or MSS UART if used for initial debug) to the PC via a USB-to-Serial adapter.
*   Prepare a terminal emulator program (e.g., PuTTY, Tera Term) for UART communication.

### 5.2. JTAG Debugging
*   **Connectivity Check:** Use FlashPro software to detect the FPGA and JTAG chain.
*   **Basic ID Register Read:** Verify JTAG communication.
*   **Boundary Scan (Optional):** Check pin connectivity if issues are suspected.
*   **Internal Probing (SmartDebug/Identify):**
    *   If the design includes debug IP like `CoreProbe` or if Libero's Identify instrumentor is used, internal signals can be probed via JTAG to observe states, especially if the system doesn't boot or UART is non-functional.
    *   This is useful for checking clock presence, reset de-assertion, and basic activity in key modules.

### 5.3. Boot ROM / UART "Hello World" Test
1.  **Load Bitstream:** Program the FPGA with the generated bitstream.
2.  **Reset the Board:** Apply a hard reset or power cycle.
3.  **Observe UART Output:**
    *   The CVA6 CPU should start executing from the Boot ROM (BRAM initialized with `boot_content.hex`).
    *   The initial Boot ROM code should initialize the UART (part of `Peripherals_Stub.v` or a fabric UART IP) and print a "Hello, Keystone SoC!" message.
    *   Verify this message appears correctly in the terminal emulator.
    *   **Debug:** If no output, check clocks, reset to UART, UART pin assignments, baud rate settings, and Boot ROM content. Use JTAG/SmartDebug to trace CVA6 execution from reset.

### 5.4. Bootloader (U-Boot) Loading and Execution
*   **Delivery Method:**
    *   **Preload into BRAM:** For initial testing, U-Boot could be loaded into a large BRAM (simulating part of main memory) during FPGA programming, and the Boot ROM could jump to its entry point.
    *   **Load via Debugger:** Use a debugger (via JTAG, if CVA6 supports it or if MSS is used to load fabric RAM) to load U-Boot into simulated DRAM (CoreDDR BRAM).
    *   **SPI Flash:** If a fabric SPI controller and flash are implemented, Boot ROM would load U-Boot from flash.
*   **Testing:**
    *   Observe U-Boot console output on UART.
    *   Verify U-Boot initializes DRAM (CoreDDR).
    *   Test basic U-Boot commands (memory read/write, environment variables).

### 5.5. Linux Kernel Boot Process and Debugging
1.  **Loading Kernel:**
    *   U-Boot loads the Linux kernel image (`Image`) and Device Tree Blob (`.dtb`) into DRAM from a pre-defined location (e.g., loaded via U-Boot TFTP, or from emulated SD/Flash).
    *   U-Boot executes `bootm` or `booti` command.
2.  **Observing Boot:**
    *   Kernel boot messages should appear on the UART console.
    *   Look for successful initialization of key drivers: PLIC, CLINT, timer, UART, memory.
    *   Crucially, look for the Keystone Coprocessor driver probing and initializing.
3.  **Root Filesystem Mount:**
    *   Kernel mounts the root filesystem (e.g., initramfs, or from SD/NFS if configured).
    *   Login prompt should appear.
4.  **Debugging:**
    *   **Early Printk:** Add debug prints in kernel drivers.
    *   **JTAG Debugger:** If a JTAG debugger is attached to CVA6 (requires CVA6 debug support), it can be used for kernel-level debugging (breakpoints, single-stepping).
    *   **QEMU Comparison:** Compare behavior with the QEMU model to isolate hardware vs. software issues.

### 5.6. Keystone Coprocessor Testing on FPGA
This requires the Linux system to be booted and the Keystone kernel driver to be loaded.
1.  **Load Kernel Module:** `insmod keystone_copro_driver.ko`. Check `dmesg` for successful loading and probing (DTB entry found, CSRs mapped, IRQ registered).
2.  **Userspace Test Application:** A custom C application will use `ioctl` calls to `/dev/keystone_copro`.
    *   **eBPF Program Loading (DMA Test):**
        *   App provides a small, known eBPF program binary.
        *   `ioctl(fd, KS_IOCTL_SELECT_VM, &vm_id);`
        *   `ioctl(fd, KS_IOCTL_LOAD_PROG, &load_prog_args);` (where `load_prog_args` contains buffer address, length, target VM's program memory offset).
        *   **Verification:**
            *   Driver configures CCU DMA registers. CCU issues `LOAD_PROG` command.
            *   Monitor AXI bus (if possible with FPGA debug tools like SmartDebug or an embedded logic analyzer) to observe DMA from main memory to Keystone's AXI master port.
            *   After DMA, use a debug mechanism (if available, e.g., PicoRV32 reads its prog_mem and outputs via mailbox) or a specialized "dump VM program memory" ioctl to verify content.
            *   Check for DMA completion interrupt.
    *   **VM Start/Stop/Reset:**
        *   `ioctl(fd, KS_IOCTL_START_VM, &vm_id);`
        *   **Verification:** Check `COPRO_STATUS_REG` (via another ioctl or debug interface) for `ACTIVE_VM_MASK`.
        *   Similarly test `STOP_VM` and `RESET_VM`.
    *   **Mailbox Communication:**
        *   **CPU to VM:**
            *   `ioctl(fd, KS_IOCTL_SEND_MAILBOX, &mbox_op_args);` (args: vm_id, mbox_idx, data).
            *   **Verification:** The PicoRV32 firmware in the target VM should be designed to read this mailbox and perhaps echo it back or perform an action.
        *   **VM to CPU:**
            *   PicoRV32 firmware writes a known value to one of its OUT mailbox registers.
            *   `ioctl(fd, KS_IOCTL_RECV_MAILBOX, &mbox_op_args);` (args: vm_id, mbox_idx, buffer to receive data).
            *   **Verification:** Verify the data read by the app matches what PicoRV32 wrote.
    *   **Interrupts (VM Done/Error):**
        *   PicoRV32 firmware sets its `done` or `error` flag.
        *   **Verification:** The application (or a separate monitoring tool) should observe the interrupt event (e.g., poll on the device file, or driver signals via a mechanism). The driver's interrupt handler should log the event. Check `INT_STATUS_REG` in CCU.
    *   **Execution of Sample eBPF Programs:**
        *   Load a simple eBPF program (e.g., basic arithmetic, read from IN mailbox, write to OUT mailbox).
        *   Provide input via IN mailbox.
        *   Start the VM.
        *   Wait for completion (VM done interrupt or polling).
        *   Read output from OUT mailbox and verify correctness.

## 6. Key Challenges for FPGA Implementation

*   **Replacing Stubs with Real IP:**
    *   **AXI Interconnect:** Moving from a conceptual stub to a fully synthesizable and correctly configured AXI interconnect (custom or IP-based) is a major task. Ensuring correct address decoding, arbitration, and AXI protocol compliance across all master/slave interactions is critical.
    *   **DDR Controller:** Integrating and calibrating the DDR controller (CoreDDR + PF_DDR_PHY) is complex and highly board-dependent. Achieving stable DRAM operation is crucial.
    *   **Clocking (PF_CCC):** Designing a robust clocking scheme with proper distribution and handling of CDC is vital for stability.
*   **Timing Closure:**
    *   Meeting timing constraints at the target clock frequencies for CVA6, Keystone Coprocessor, and the AXI interconnect can be challenging, especially with complex paths and high resource utilization.
    *   Multiple iterations of synthesis, P&R, constraint adjustments, and potentially RTL changes will likely be needed.
*   **Memory Initialization:** Ensuring all ROMs (Boot ROM, Nano-controller ROMs) and initial RAM states are correctly packaged into the bitstream and loaded onto the FPGA.
*   **On-Board Debugging:**
    *   Limited visibility into the FPGA compared to simulation.
    *   Effective use of JTAG-based debug tools (SmartDebug, CoreProbe) and embedded logic analyzers will be essential.
    *   Debugging issues that only appear on hardware (e.g., related to external interfaces like DDR or specific timing conditions).
*   **PicoRV32 Firmware Development and Debug:**
    *   Developing and debugging the uBPF interpreter and helper functions for the PicoRV32 nano-controllers.
    *   Testing this firmware will initially rely on its interaction with the rest of the system (e.g., mailbox behavior observed by CVA6).
*   **Full System Integration:** Ensuring all components (CVA6, Keystone, Interconnect, Peripherals, Memory) work together correctly as a cohesive system.
*   **Driver and Software Bring-up:** Debugging issues that span hardware/software boundaries (e.g., kernel driver interaction with Keystone CSRs and interrupts).

This plan provides a structured approach to tackling the FPGA deployment of the Keystone SoC. Flexibility and iterative refinement will be key to addressing the challenges encountered.
